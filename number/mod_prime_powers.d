// mod 2^E
template ModULong(int E) {
  import std.algorithm.comparison : max, min;
  import std.typecons : Tuple;
  import core.bitop : bsf;

  static assert(1 <= E, "ModULong: 1 <= E must hold");
  static assert(E <= 64, "ModULong: E <= 64 must hold");
  enum F = max(E / 2, 2);
  enum MASK = (E >= 64) ? ~0UL : ((1UL << min(E, 63)) - 1);  // min for compiler

  // v_2(n!)
  enum VAL_FAC = [0, 0, 1, 1, 3, 3, 4, 4, 7, 7, 8, 8, 10, 10, 11, 11, 15, 15, 16, 16, 18, 18, 19, 19, 22, 22, 23, 23, 25, 25, 26, 26, 31, 31, 32, 32, 34, 34, 35, 35, 38, 38, 39, 39, 41, 41, 42, 42, 46, 46, 47, 47, 49, 49, 50, 50, 53, 53, 54, 54, 56, 56, 57, 57, 63];
  // (n! / v_2(n!))^-1
  enum INV_FAC = [1UL, 1UL, 1UL, 12297829382473034411UL, 12297829382473034411UL, 17216961135462248175UL, 5738987045154082725UL, 3455104445551947763UL, 3455104445551947763UL, 10632091646011078427UL, 13194464773427946655UL, 12938333935399527997UL, 16610607360939543743UL, 14048561848025039099UL, 17818432327183192685UL, 13485724870951913923UL, 13485724870951913923UL, 12729406451868057747UL, 13712207877125040827UL, 7517864020689047481UL, 16260968063105450789UL, 4287997350378269393UL, 8774701610811457043UL, 15620123435273605989UL, 5206707811757868663UL, 5373356653108989199UL, 10346197320698142347UL, 3116043467242086993UL, 5715647373523027175UL, 3377564404898992595UL, 12523000342799633917UL, 1594080273878023779UL, 1594080273878023779UL, 13464119334633553411UL, 14898340723109277907UL, 17818311290157842321UL, 4029450595985265993UL, 5094510576569750869UL, 11918707340057072119UL, 5508535696175952305UL, 1101707139235190461UL, 18023694392380908661UL, 2615103930466667233UL, 3921762804508200739UL, 15449314497081287753UL, 15510641004985215501UL, 12704860961331673467UL, 8119994519904738421UL, 15004494222441280551UL, 1435606662113672151UL, 10387600947761895791UL, 4905789684431099349UL, 11729210944162116329UL, 13795325090921408101UL, 12125554605332732799UL, 13971673847771351801UL, 4631202560211557631UL, 81249167723009783UL, 12088599536834637603UL, 11460531969328449081UL, 11832081908847627575UL, 11685382896882140803UL, 14658298085997141277UL, 6088780627939494819UL, 6088780627939494819UL];
  // n!_2 = \prod_{1<=i<=n, i:odd} i
  enum FAC_SKIPPED = [1UL, 1UL, 1UL, 3UL, 3UL, 15UL, 15UL, 105UL, 105UL, 945UL, 945UL, 10395UL, 10395UL, 135135UL, 135135UL, 2027025UL, 2027025UL, 34459425UL, 34459425UL, 654729075UL, 654729075UL, 13749310575UL, 13749310575UL, 316234143225UL, 316234143225UL, 7905853580625UL, 7905853580625UL, 213458046676875UL, 213458046676875UL, 6190283353629375UL, 6190283353629375UL, 191898783962510625UL, 191898783962510625UL, 6332659870762850625UL, 6332659870762850625UL, 282166592185152483UL, 282166592185152483UL, 10440163910850641871UL, 10440163910850641871UL, 1338022901564897417UL, 1338022901564897417UL, 17965450816741690865UL, 17965450816741690865UL, 16197878097801090939UL, 16197878097801090939UL, 9481495526376579231UL, 9481495526376579231UL, 2908431970669985073UL, 2908431970669985073UL, 13385958046862407265UL, 13385958046862407265UL, 154329662729360723UL, 154329662729360723UL, 8179472124656118319UL, 8179472124656118319UL, 7149109087057268761UL, 7149109087057268761UL, 1670848340654183825UL, 1670848340654183825UL, 6346331730049087595UL, 6346331730049087595UL, 18191354058803310975UL, 18191354058803310975UL, 2357173134616391233UL, 2357173134616391233UL];
  // (n!_2)^-1 = \prod_{1<=i<=n, i:odd} i^-1
  enum INV_FAC_SKIPPED = [1UL, 1UL, 1UL, 12297829382473034411UL, 12297829382473034411UL, 17216961135462248175UL, 17216961135462248175UL, 10365313336655843289UL, 10365313336655843289UL, 13449530864323683665UL, 13449530864323683665UL, 9607568293897403795UL, 9607568293897403795UL, 4995984655002004511UL, 4995984655002004511UL, 5252197396656014065UL, 5252197396656014065UL, 6819568343465489633UL, 6819568343465489633UL, 7155093518917492155UL, 7155093518917492155UL, 340718738996071055UL, 340718738996071055UL, 7233105017494871113UL, 7233105017494871113UL, 5454412541338469297UL, 5454412541338469297UL, 11133419174840418339UL, 11133419174840418339UL, 6744857238342618431UL, 6744857238342618431UL, 3192857342157754081UL, 3192857342157754081UL, 2891714476081985217UL, 2891714476081985217UL, 9569517365795826123UL, 9569517365795826123UL, 14716894473064130351UL, 14716894473064130351UL, 7945251273138896313UL, 7945251273138896313UL, 13691404231327449873UL, 13691404231327449873UL, 11472250003436646323UL, 11472250003436646323UL, 9273347102778817375UL, 9273347102778817375UL, 11579338834901187537UL, 11579338834901187537UL, 612777202216545697UL, 612777202216545697UL, 2905622152782214875UL, 2905622152782214875UL, 750926609437760719UL, 750926609437760719UL, 12087885695690574889UL, 12087885695690574889UL, 1830203615162076017UL, 1830203615162076017UL, 13787914285735294019UL, 13787914285735294019UL, 13229473925495836287UL, 13229473925495836287UL, 5480489956385202625UL, 5480489956385202625UL];

  ulong inv(ulong a) {
    assert(a & 1, "ModULong.inv: a must be odd");
    ulong b = (3 * a) ^ 2;
    b *= (2 - a * b);
    b *= (2 - a * b);
    b *= (2 - a * b);
    b *= (2 - a * b);
    b &= MASK;
    return b;
  }
  ulong power(ulong a, ulong e) {
    ulong b = 1;
    for (; e; e >>= 1, a *= a) if (e & 1) b *= a;
    b &= MASK;
    return b;
  }
  // \prod_{-F<=i<=F, i!=-j,j} (u-i)/(j-i)
  ulong coefB(int j, ulong u) {
    assert(F < u, "ModULong.coefB: F < u must hold");
    assert(u <= (~0UL) - F, "ModULong.coefB: u < 2^64 - F must hold");
    int s = 0;
    ulong x = 1;
    foreach (i; -F .. F + 1) if (i != -j && i != j) {
      if (u == i) return 0UL;
      const t = bsf(u - i);
      s += t;
      x *= ((u - i) >> t);
    }
    s += bsf(j + j);
    x *= ((j + j) >> bsf(j + j));
    s -= (VAL_FAC[F + j] + VAL_FAC[F - j]);
    x *= (INV_FAC[F + j] * INV_FAC[F - j]);
    if ((F - j) & 1) x = -x;
    assert(s >= 0);
    return (s >= 64) ? 0UL : ((x << s) & MASK);
  }
  // n!_2 = \prod_{1<=i<=n, i:odd} i
  ulong facSkipped(ulong n) {
    if (n <= 64) return FAC_SKIPPED[cast(size_t)(n)];
    const u = (n >> 1) + (n & 1);
    ulong x = 1;
    foreach (j; 1 .. F + 1) x *= power(FAC_SKIPPED[j << 1], coefB(j, u));
    if ((x ^ u) & 2) x = -x;
    x &= MASK;
    return x;
  }

  // 2^s x
  alias Pair = Tuple!(ulong, "s", ulong, "x");
  ulong get(const(Pair) p) {
    return (p.s >= 64) ? 0UL : ((p.x << p.s) & MASK);
  }
  Pair facPair(ulong n) {
    auto p = Pair(0UL, 1UL);
    for (; n > 1; n >>= 1) {
      p.s += (n >> 1);
      p.x *= facSkipped(n);
    }
    p.x &= MASK;
    return p;
  }
  ulong fac(ulong n) {
    return get(facPair(n));
  }
  Pair binomPair(ulong n, ulong k) {
    if (!(0 <= k && k <= n)) return Pair(0UL, 0UL);
    const f0 = facPair(n), f1 = facPair(k), f2 = facPair(n - k);
    assert(f0.s >= f1.s + f2.s);
    return Pair(f0.s - (f1.s + f2.s), (f0.x * inv(f1.x * f2.x)) & MASK);
  }
  ulong binom(ulong n, ulong k) {
    return get(binomPair(n, k));
  }
}

unittest {
  import core.bitop : bsf;

  alias U3 = ModULong!3;
  alias U29 = ModULong!29;
  alias U64 = ModULong!64;
  enum MASK3 = (1L << 3) - 1;
  enum MASK29 = (1L << 29) - 1;

  enum LIM_FAC = 10^^4;
  enum LIM_BN = 10^^2;

  auto fac = new ulong[LIM_FAC];
  auto valFac = new ulong[LIM_FAC];
  auto baseFac = new ulong[LIM_FAC];
  auto facSkipped = new ulong[LIM_FAC];
  fac[0] = baseFac[0] = facSkipped[0] = 1;
  foreach (n; 1 .. LIM_FAC) {
    fac[n] = fac[n - 1] * n;
    valFac[n] = valFac[n - 1] + bsf(n);
    baseFac[n] = baseFac[n - 1] * (n >> bsf(n));
    facSkipped[n] = facSkipped[n - 1] * ((n & 1) ? n : 1);
  }
  auto bn = new ulong[][](LIM_BN, LIM_BN);
  foreach (n; 0 .. LIM_BN) {
    bn[n][0] = bn[n][n] = 1;
    foreach (k; 1 .. n) {
      bn[n][k] = bn[n - 1][k - 1] + bn[n - 1][k];
    }
  }

  foreach (i; 0 .. 64 + 1) {
    assert(U64.VAL_FAC[i] == valFac[i]);
    assert(U64.INV_FAC[i] * baseFac[i] == 1UL);
    assert(U64.FAC_SKIPPED[i] == facSkipped[i]);
    assert(U64.INV_FAC_SKIPPED[i] * facSkipped[i] == 1UL);
  }

  void checkFac(ulong n, ulong expected) {
    assert(U3.fac(n) == (expected & MASK3));
    assert(U29.fac(n) == (expected & MASK29));
    assert(U64.fac(n) == expected);
  }
  void checkBinom(ulong n, ulong k, ulong expected) {
    assert(U3.binom(n, k) == (expected & MASK3));
    assert(U29.binom(n, k) == (expected & MASK29));
    assert(U64.binom(n, k) == expected);
  }

  foreach (n; 0 .. LIM_FAC) {
    checkFac(n, fac[n]);
  }
  foreach (n; 0 .. LIM_BN) foreach (k; 0 .. LIM_BN) {
    checkBinom(n, k, bn[n][k]);
  }
}

void main() {
}
